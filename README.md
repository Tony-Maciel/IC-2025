# IC-2025 (Monte Carlo techniques applied to phase transitions in magnetic systems)
This repository contains the main programs used for my cientific initiation in 2025 at the University of SÃ£o Paulo with funding from FAPESP. These programs include: classical Monte Carlo simulations of a couple models in statistical physics and programs to visualize the data. 

## DISCLAIMER 
The opinions, hypotheses, conclusions, or recommendations expressed in this material are the responsibility of the author(s) and do not necessarily reflect the views of FAPESP.

### Organization of programs
In this repository there are 4 main directories, corresponding to each of the 4 different models that were studied. These are the: 2D Ising model, 2D XY model, 2D clock model and 2D XY J1-J2 model. Inside each of these directories there should be various programs with names corresponding to the type of algorithm used and some other files for the pseudorandom number generator (PRNG) used. Each of these programs and PRNG files are self-contained for convenience, so, for example, to simulate the 2D XY J1-J2 model, all that has to be done is to go to its directory, choose a file with the desired algorithm, copy it to your pc along with the PRNG in the same directory and the input file, change the parameters in the input file, compile and execute your program (there are instructions on how to do so at the start of each file). 

Inside each program, the code is organized into two derived types in fortran (fortran equivalent of classes) or two structs in C++ which correspond to the system being simulated and the observer with their notes. Whenever a program runs, both the system and the observer are initialized (i.e., the experimentalist prepares the system and gathers their tools to measure it). Afterwards, the system evolves in time from the use of the method/subroutine specific to its class, which invokes a single "Monte Carlo step" with a given algorithm. Once the system has reached equilibrium, the observer can start taking notes, by calling the method/subroutine to measure properties of the system at that instant in time (this does NOT affect the system in any way). Once a sufficient amount of notes have been taken, some averages can be performed, the results are saved to an output file and the vectors used can be deallocated.

### Caveats
- Before using any of the programs here, I highly recommend reading my report (report.pdf) to cast away any potential doubts. There, I explicitly show the Hamiltonian used for all these models, along with lengthy explanations on the motivation and calculation of all the variables that were used in the programs, such as the Binder cumulant, helicity modulus, nematic order parameter etc. 
- The PRNGs used by these programs are either ranlux++ (written in C++ with a fortran wrapper), rkiss05 (written in fortran) or xoshiro256+ (written in C and used in C++). It's important not to assume they all use the same PRNG.
- Even though the structure of each program (with the exception of the 2D XY J1-J2 model) is made to be able to simulate that same model in N dimensions, in my own work, I only studied them in 2D. Because of this, and the fact that the 2D Ising model has a critical temperature (Tc) that is known exactly, I made it so that, in the Ising model, when you input the desired initial and final temperatures to simulate in the input file (say 0.9 and 1.1), the programs would calculate the actual initial and final temperatures based off the percentage of the known critical temperature (0.9Tc = 90%Tc and 1.1Tc = 110%Tc). For the other models this isn't the case (an initial temperature of ,e.g., 0.5 will make the simulation start with this temperature in the appropriate units).
- For the Ising model, if the Wolff or Swendsen-Wang algorithms are chosen, it's important to take note that the magnetization calculated is actually the magnetization squared. This is because, below Tc, both of these algorithms basically flip most spins after just a single Monte Carlo step, so the average magnetization would be always zero, regardless of the temperature, invalidating it as an order parameter. For the Metropolis and heat bath algorithms this isn't the case (for sufficiently large systems), so the average magnetization was used.
- The error for some observables weren't calculated because it is assumed that these programs are to be executed across multiple computers (trivially parallel) and their results gathered to calculate the mean and standard deviation. If one chooses not to do so, then some lines of code have to be uncommented in the desired program: this will estimate the error of some observables with the bootstrap method. The reason I decided not to use the boostrap method was because, in my experience, the errors from the boostrap method are always pretty large, so since I already had access to a computer cluster, I could just run the program across many nodes and make the standard deviation be very small.
